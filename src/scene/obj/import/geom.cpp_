#include <aecl/scene/import.hpp>
#include <amal/integration/acul/string.hpp>
#include <oneapi/tbb/concurrent_vector.h>

namespace aecl
{
    namespace scene
    {
        namespace obj
        {

            template <typename T>
            struct Line
            {
                int index; // Line index
                T value;   // Line content

                bool operator<(const Line &other) const { return index < other.index; }
            };

            template <template <typename> class Container>
            struct ParseData
            {
                Container<Line<amal::vec3>> v;
                Container<Line<amal::vec2>> vt;
                Container<Line<amal::vec3>> vn;
                Container<Line<acul::vector<amal::ivec3> *>> f;
                Container<Line<acul::string>> g;
                acul::string mtllib;
                Container<Line<acul::string>> use_mtl;
            };

            using ParseDataWrite = ParseData<oneapi::tbb::concurrent_vector>;
            using ParseDataRead = ParseData<acul::vector>;

            void parse_line(ParseDataWrite &data, acul::string_view line, int line_index)
            {
                if (line[0] == '\0' || line[0] == '#') return;
                const char *token = line.data();
                if (token[0] == 'v')
                {
                    if (isspace(token[1]))
                    {
                        token += 2;
                        amal::vec3 v;
                        if (acul::stov3(token, v)) data.v.push_back({line_index, v});
                    }
                    else if (token[1] == 't')
                    {
                        token += 3;
                        amal::vec2 vt;
                        if (acul::stov2(token, vt)) data.vt.push_back({line_index, vt});
                    }
                    else if (token[1] == 'n')
                    {
                        token += 3;
                        amal::vec3 vn;
                        if (acul::stov3(token, vn)) data.vn.push_back({line_index, vn});
                    }
                }
                else if (token[0] == 'g' || token[0] == 'o')
                {
                    ++token;
                    const char *end = line.data() + line.size();
                    while (token < end && (*token == ' ' || *token == '\t')) ++token;
                    if (token < end)
                    {
                        size_t len = static_cast<size_t>(end - token);
                        acul::string name = acul::trim_end(token, len);
                        data.g.push_back({line_index, name});
                    }
                }

                else if (token[0] == 'f')
                {
                    token += 2;
                    acul::vector<amal::ivec3> *vtn = acul::alloc<acul::vector<amal::ivec3>>();
                    while (true)
                    {
                        int v_id{0}, vt_id{0}, vn_id{0};
                        if (!(acul::stoi(token, v_id))) break;
                        // Handle negative indices
                        if (v_id < 0) v_id += data.v.size() + 1;

                        if (v_id > 0)
                        {
                            // Changed this section
                            if (*token == '/')
                            {
                                ++token;
                                if (acul::stoi(token, vt_id))
                                    if (vt_id < 0) vt_id += data.vt.size() + 1;
                                if (*token == '/')
                                {
                                    ++token;
                                    if (acul::stoi(token, vn_id))
                                        if (vn_id < 0) vn_id += data.vn.size() + 1;
                                }
                            }
                            vtn->emplace_back(v_id, vt_id, vn_id);

                            // Skip spaces
                            while (isspace(*token)) ++token;
                        }
                        else break;
                    }

                    data.f.push_back({line_index, vtn});
                }
                else if (strncmp(token, "mtllib", 6) == 0)
                {
                    token += 7;
                    const char *end = line.data() + line.size();
                    while (token < end && (*token == ' ' || *token == '\t')) ++token;
                    ptrdiff_t len = end - token;
                    data.mtllib = acul::strip_controls(token, len);
                }
                else if (strncmp(token, "usemtl", 6) == 0)
                {
                    token += 7;
                    const char *end = line.data() + line.size();
                    while (token < end && (*token == ' ' || *token == '\t')) ++token;
                    ptrdiff_t len = end - token;
                    data.use_mtl.push_back({line_index, acul::strip_controls(token, len)});
                }
            }
        } // namespace obj
    } // namespace scene
} // namespace aecl